# Hemera grammar

# Tokens

letter = "A" | "B" | "C" | "D" | "E" | "F" | "G"
    | "H" | "I" | "J" | "K" | "L" | "M" | "N"
    | "O" | "P" | "Q" | "R" | "S" | "T" | "U"
    | "V" | "W" | "X" | "Y" | "Z" | "a" | "b"
    | "c" | "d" | "e" | "f" | "g" | "h" | "i"
    | "j" | "k" | "l" | "m" | "n" | "o" | "p"
    | "q" | "r" | "s" | "t" | "u" | "v" | "w"
    | "x" | "y" | "z" ;

digit = "0" | "1" | "2" | "3" | "4" | "5" | "6" | "7" | "8" | "9" ;

identifier = letter , { letter | digit | "_" } ;

directory_character = letter | digit | "_" | "-" ;

S = { " " | "\n" | "\t" | "\r" | "\f" | "\b" } ;

block_start = "{" ;
block_end = "}" ;

KEYWORD_underscore = "_" ;
KEYWORD_alias = "alias" ;
KEYWORD_all = "all" ;
KEYWORD_break = "break" ;
KEYWORD_case = "case" ;
KEYWORD_const = "const" ;
KEYWORD_context = "context" ;
KEYWORD_continue = "continue" ;
KEYWORD_distinct = "distinct" ;
KEYWORD_do = "do" ;
KEYWORD_else = "else" ;
KEYWORD_enum = "enum" ;
KEYWORD_false = "false" ;
KEYWORD_for = "for" ;
KEYWORD_fn = "fn" ;
KEYWORD_if = "if" ;
KEYWORD_import = "import" ;
KEYWORD_match = "match" ;
KEYWORD_mut = "mut" ;
KEYWORD_null = "null" ;
KEYWORD_package = "package" ;
KEYWORD_return = "return" ;
KEYWORD_struct = "struct" ;
KEYWORD_switch = "switch" ;
KEYWORD_true = "true" ;
KEYWORD_union = "union" ;
KEYWORD_using = "using" ;
KEYWORD_void = "void" ;
KEYWORD_while = "while" ;

OPERATOR_type_indicator = ":" ;
OPERATOR_constant_decl = ":" ;
OPERATOR_mutable_decl = "=" ;

OPERATOR_plus = "+" ;
OPERATOR_minus = "-" ;
OPERATOR_divide = "/" ;
OPERATOR_multiply = "*" ;
OPERATOR_modulus = "%" ;
OPERATOR_remainder = "%%" ;
OPERATOR_bitwise_or = "|" ;
OPERATOR_bitwise_and = "&" ;
OPERATOR_bitwise_xor = "~" ;
OPERATOR_left_shift = "<<" ;
OPERATOR_right_shift_arithmetic = ">>" ;
OPERATOR_right_shift_logical = ">>>" ;

OPERATOR_pipe = "|>" ;

# Definitions

file = package_statement , imports , const_definitions ;

package_statement = KEYWORD_package , identifier ;

imports = import , [ imports ] ;
import = KEYWORD_import , relative_package_name, [ identifier ] ;
relative_package_name = '"' , [ identifier , ":"  ] , package_path , '"' ;
package_path = directory_path , "/", identifier ;
directory_path = ( directory_name , directory_path ) 
    | directory_name
    ;
directory_name = directory_character , { directory_character } ;

const_definitions = const_definition , { const_definitions } ;
const_definition = OPERATOR_type_indicator , [ type ] , OPERATOR_constant_decl ;

decl_rhs = expression
    | function_decl
    | struct_decl
    | union_decl
    | enum_decl
    ;

function_decl = function_signature , function_body ;
struct_decl = KEYWORD_struct , [ generic_tag ] , block_start , struct_body , block_end ;
union_decl = KEYWORD_union , [ generic_tag ] , block_start , union_body , block_end ;
enum_decl = KEYWORD_enum , block_start , enum_body , block_end ;

type = ; #TODO(ches)

expression = ; #TODO(ches)
function_signature = KEYWORD_fn , [ generic_tag ], "(" , [ function_parameter_list ] , ")" , [ "->" , function_output_list ];
function_parameter_list = ( function_parameter , { "," , function_parameter } )
    | ( "(" , function_parameter , { "," , function_parameter }, ")" )
    ;
function_output_list = KEYWORD_void 
    | ( type , { "," , type } )
    | ( "(" , identifier , ":", type , { "," , identifier , ":", type }, ")" )
    ;
function_parameter = ( identifier , ":", type )
    | ( identifier , ":=", default_value )
    ;
function_body = ; #TODO(ches)
default_value = ; #TODO(ches)

struct_body = ; #TODO(ches)
union_body = ; #TODO(ches)
enum_body = ; #TODO(ches)

generic_tag = "<" , identifier , { "," , identifier } , ">" ;

pointer_type = "ptr" , "<" , type , ">" ;
