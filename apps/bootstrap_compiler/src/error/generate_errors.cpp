#include <iostream>
#include <format>
#include <fstream>
#include <string>
#include <string_view>
#include <vector>

static std::string format_enum(std::string_view name,
	std::string_view description) 
{
	return std::format(R"(		// {}
		{},
)", description, name);
}

static std::string format_struct(std::string_view type, std::string_view name,
	std::string_view description) 
{
	return std::format(R"(		{{ {0}Code::{1}, {{ "{1}", "{2}" }} }},
)", type, name, description);
}

struct Input {
	std::string code;
	std::string description;
};

static void output_header(std::vector<Input>& inputs, const char* input_name,
	const char* replacement) {

	std::cout << std::format(R"(
#pragma once

//NOTE(ches) This file is autogenerated from {1}, please do not modify it

#include <map>

namespace hemera {{

	enum class {0}Code {{
)", replacement, input_name);
	for (const auto& input : inputs) {
		std::cout << format_enum(input.code, input.description);
	}
	std::cout << std::format(R"DONE(
	}};
	struct {0}Info {{
		const char* string_value;
		const char* message;

		{0}Info(const char* string_value, const char* message);
		{0}Info(const {0}Info& other);
		{0}Info({0}Info&& other) noexcept;
		{0}Info& operator=(const {0}Info& other);
		{0}Info& operator=({0}Info&& other) noexcept = delete;
		~{0}Info();
	}};

	extern std::map<{0}Code, {0}Info> {0}InfoMap;
}}
)DONE", replacement);

	std::cout << std::endl;
}

static void output_cpp(std::vector<Input>& inputs, const char* input_name, 
	const char* output_name, const char* replacement) {
	
	std::cout << "#include \"" << output_name << ".h\"";
	std::cout << std::format(R"DONE(

//NOTE(ches) This file is autogenerated from {1}, please do not modify it

namespace hemera {{

	{0}Info::{0}Info(const char* string_value, const char* message)
		: string_value{{ string_value }}
		, message{{ message }}
	{{}}
	{0}Info::{0}Info(const {0}Info& other)
		: string_value{{ other.string_value }}
		, message{{ other.message }}
	{{}}
	{0}Info::{0}Info({0}Info&& other) noexcept
		: string_value{{ std::move(other.string_value) }}
		, message{{ std::move(other.message) }}
	{{}}
	{0}Info& {0}Info::operator=(const {0}Info& other) {{
		string_value = other.string_value;
		message = other.message;
		return *this;
	}}
	{0}Info::~{0}Info() = default;

	std::map<{0}Code, {0}Info> {0}InfoMap = {{
)DONE", replacement , input_name);
	
	for (const auto& input : inputs) {
		std::string value = format_struct(replacement, input.code, input.description);
		std::cout << value;
	}

	std::cout << R"(
	};
}
)" << std::endl;
}


int main(int argc, char* argv[])
{
	if (argc != 4) {
		std::cerr << "Incorrect number of arguments" << std::endl;
		return 1;
	}
	const char* output_name = argv[1];
	const char* output_type = argv[2];
	const char* input_name = argv[3];

	const char* replacement;
	if (strncmp(output_name, "errors", 5) == 0) {
		replacement = "Error";
	}
	else if (strncmp(output_name, "warnings", 7) == 0) {
		replacement = "Warning";
	}
	else {
		std::cerr << "Unknown replacement type" << std::endl;
		return 1;
	}

	bool header;
	if (strncmp(output_type, "hpp", 5) == 0) {
		header = true;
	}
	else if (strncmp(output_type, "cpp", 7) == 0) {
		header = false;
	}
	else {
		std::cerr << "Unknown file type" << std::endl;
		return 1;
	}

	std::ifstream input_file;
	input_file.open(input_name);

	if (!input_file.is_open()) {
		std::cerr << "Unknown file" << std::endl;
		return 1;
	}

	std::string line;
	std::vector<Input> inputs;

	while (std::getline(input_file, line)) {
		if (line.empty()) {
			continue;
		}
		size_t first_comma = line.find(",");
		if (first_comma == std::string::npos) {
			std::cerr << "Bad file format" << std::endl;
			return 1;
		}
		inputs.emplace_back(line.substr(0, first_comma), line.substr(first_comma + 1));
	}

	if (header) {
		output_header(inputs, input_name, replacement);
	}
	else {
		output_cpp(inputs, input_name, output_name, replacement);
	}

	return 0;
}